// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const blockSession = `-- name: BlockSession :one
UPDATE sessions
SET is_blocked = TRUE
WHERE id = $1
RETURNING id, user_id, refresh_token, user_agent, client_ip, is_blocked, expires_at, created_at
`

func (q *Queries) BlockSession(ctx context.Context, id pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, blockSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createChapter = `-- name: CreateChapter :one
INSERT INTO chapters (
    project_id, type, title, content, word_count
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, project_id, type, title, content, word_count, status, created_at, updated_at
`

type CreateChapterParams struct {
	ProjectID pgtype.UUID `db:"project_id" json:"project_id"`
	Type      string      `db:"type" json:"type"`
	Title     string      `db:"title" json:"title"`
	Content   pgtype.Text `db:"content" json:"content"`
	WordCount pgtype.Int4 `db:"word_count" json:"word_count"`
}

func (q *Queries) CreateChapter(ctx context.Context, arg CreateChapterParams) (Chapter, error) {
	row := q.db.QueryRow(ctx, createChapter,
		arg.ProjectID,
		arg.Type,
		arg.Title,
		arg.Content,
		arg.WordCount,
	)
	var i Chapter
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Type,
		&i.Title,
		&i.Content,
		&i.WordCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGeneratedDocument = `-- name: CreateGeneratedDocument :one
INSERT INTO generated_documents (
    project_id, file_name, file_path, file_size, mime_type
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, project_id, file_name, file_path, file_size, mime_type, status, created_at
`

type CreateGeneratedDocumentParams struct {
	ProjectID pgtype.UUID `db:"project_id" json:"project_id"`
	FileName  string      `db:"file_name" json:"file_name"`
	FilePath  string      `db:"file_path" json:"file_path"`
	FileSize  pgtype.Int8 `db:"file_size" json:"file_size"`
	MimeType  pgtype.Text `db:"mime_type" json:"mime_type"`
}

func (q *Queries) CreateGeneratedDocument(ctx context.Context, arg CreateGeneratedDocumentParams) (GeneratedDocument, error) {
	row := q.db.QueryRow(ctx, createGeneratedDocument,
		arg.ProjectID,
		arg.FileName,
		arg.FilePath,
		arg.FileSize,
		arg.MimeType,
	)
	var i GeneratedDocument
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createReference = `-- name: CreateReference :one
INSERT INTO "references" ( -- Quoted
    project_id, title, authors, journal, publication_year, doi, url, citation_apa, citation_mla
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, project_id, title, authors, journal, publication_year, doi, url, citation_apa, citation_mla, created_at
`

type CreateReferenceParams struct {
	ProjectID       pgtype.UUID `db:"project_id" json:"project_id"`
	Title           string      `db:"title" json:"title"`
	Authors         pgtype.Text `db:"authors" json:"authors"`
	Journal         pgtype.Text `db:"journal" json:"journal"`
	PublicationYear pgtype.Int4 `db:"publication_year" json:"publication_year"`
	Doi             pgtype.Text `db:"doi" json:"doi"`
	Url             pgtype.Text `db:"url" json:"url"`
	CitationApa     pgtype.Text `db:"citation_apa" json:"citation_apa"`
	CitationMla     pgtype.Text `db:"citation_mla" json:"citation_mla"`
}

func (q *Queries) CreateReference(ctx context.Context, arg CreateReferenceParams) (Reference, error) {
	row := q.db.QueryRow(ctx, createReference,
		arg.ProjectID,
		arg.Title,
		arg.Authors,
		arg.Journal,
		arg.PublicationYear,
		arg.Doi,
		arg.Url,
		arg.CitationApa,
		arg.CitationMla,
	)
	var i Reference
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Authors,
		&i.Journal,
		&i.PublicationYear,
		&i.Doi,
		&i.Url,
		&i.CitationApa,
		&i.CitationMla,
		&i.CreatedAt,
	)
	return i, err
}

const createResearchProject = `-- name: CreateResearchProject :one
INSERT INTO research_projects (
    user_id, title, specialization, university, description
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, title, specialization, university, description, status, created_at, updated_at
`

type CreateResearchProjectParams struct {
	UserID         pgtype.UUID `db:"user_id" json:"user_id"`
	Title          string      `db:"title" json:"title"`
	Specialization string      `db:"specialization" json:"specialization"`
	University     pgtype.Text `db:"university" json:"university"`
	Description    pgtype.Text `db:"description" json:"description"`
}

func (q *Queries) CreateResearchProject(ctx context.Context, arg CreateResearchProjectParams) (ResearchProject, error) {
	row := q.db.QueryRow(ctx, createResearchProject,
		arg.UserID,
		arg.Title,
		arg.Specialization,
		arg.University,
		arg.Description,
	)
	var i ResearchProject
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Specialization,
		&i.University,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one

INSERT INTO sessions (
    id, user_id, refresh_token, user_agent, client_ip, is_blocked, expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, refresh_token, user_agent, client_ip, is_blocked, expires_at, created_at
`

type CreateSessionParams struct {
	ID           pgtype.UUID        `db:"id" json:"id"`
	UserID       pgtype.UUID        `db:"user_id" json:"user_id"`
	RefreshToken string             `db:"refresh_token" json:"refresh_token"`
	UserAgent    pgtype.Text        `db:"user_agent" json:"user_agent"`
	ClientIp     pgtype.Text        `db:"client_ip" json:"client_ip"`
	IsBlocked    pgtype.Bool        `db:"is_blocked" json:"is_blocked"`
	ExpiresAt    pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
}

// Ensure user owns project for delete if needed, or handled at service layer
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.RefreshToken,
		arg.UserAgent,
		arg.ClientIp,
		arg.IsBlocked,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email, password_hash, first_name, last_name
) VALUES (
    $1, $2, $3, $4
) RETURNING id, email, password_hash, first_name, last_name, is_verified, created_at, updated_at
`

type CreateUserParams struct {
	Email        string `db:"email" json:"email"`
	PasswordHash string `db:"password_hash" json:"password_hash"`
	FirstName    string `db:"first_name" json:"first_name"`
	LastName     string `db:"last_name" json:"last_name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteChapter = `-- name: DeleteChapter :exec
DELETE FROM chapters
WHERE chapters.id = $1 AND project_id = (SELECT project_id FROM research_projects WHERE research_projects.id = $2 AND user_id = $3)
`

type DeleteChapterParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	ID_2   pgtype.UUID `db:"id_2" json:"id_2"`
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteChapter(ctx context.Context, arg DeleteChapterParams) error {
	_, err := q.db.Exec(ctx, deleteChapter, arg.ID, arg.ID_2, arg.UserID)
	return err
}

const deleteGeneratedDocument = `-- name: DeleteGeneratedDocument :exec
DELETE FROM generated_documents
WHERE id = $1
`

func (q *Queries) DeleteGeneratedDocument(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteGeneratedDocument, id)
	return err
}

const deleteReference = `-- name: DeleteReference :exec
DELETE FROM "references" -- Quoted
WHERE id = $1 AND project_id = $2
`

type DeleteReferenceParams struct {
	ID        pgtype.UUID `db:"id" json:"id"`
	ProjectID pgtype.UUID `db:"project_id" json:"project_id"`
}

func (q *Queries) DeleteReference(ctx context.Context, arg DeleteReferenceParams) error {
	_, err := q.db.Exec(ctx, deleteReference, arg.ID, arg.ProjectID)
	return err
}

const deleteResearchProject = `-- name: DeleteResearchProject :exec
DELETE FROM research_projects
WHERE id = $1 AND user_id = $2
`

type DeleteResearchProjectParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteResearchProject(ctx context.Context, arg DeleteResearchProjectParams) error {
	_, err := q.db.Exec(ctx, deleteResearchProject, arg.ID, arg.UserID)
	return err
}

const deleteSessionByRefreshToken = `-- name: DeleteSessionByRefreshToken :exec
DELETE FROM sessions
WHERE refresh_token = $1
`

func (q *Queries) DeleteSessionByRefreshToken(ctx context.Context, refreshToken string) error {
	_, err := q.db.Exec(ctx, deleteSessionByRefreshToken, refreshToken)
	return err
}

const getChapterByProjectIDAndType = `-- name: GetChapterByProjectIDAndType :one
SELECT id, project_id, type, title, content, word_count, status, created_at, updated_at FROM chapters
WHERE project_id = $1 AND type = $2 LIMIT 1
`

type GetChapterByProjectIDAndTypeParams struct {
	ProjectID pgtype.UUID `db:"project_id" json:"project_id"`
	Type      string      `db:"type" json:"type"`
}

func (q *Queries) GetChapterByProjectIDAndType(ctx context.Context, arg GetChapterByProjectIDAndTypeParams) (Chapter, error) {
	row := q.db.QueryRow(ctx, getChapterByProjectIDAndType, arg.ProjectID, arg.Type)
	var i Chapter
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Type,
		&i.Title,
		&i.Content,
		&i.WordCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChaptersByProjectID = `-- name: GetChaptersByProjectID :many
SELECT id, project_id, type, title, content, word_count, status, created_at, updated_at FROM chapters
WHERE project_id = $1
ORDER BY
    CASE type
        WHEN 'introduction' THEN 1
        WHEN 'literature_review' THEN 2
        WHEN 'methodology' THEN 3
        WHEN 'results' THEN 4
        WHEN 'conclusion' THEN 5
        ELSE 6
    END
`

func (q *Queries) GetChaptersByProjectID(ctx context.Context, projectID pgtype.UUID) ([]Chapter, error) {
	rows, err := q.db.Query(ctx, getChaptersByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chapter{}
	for rows.Next() {
		var i Chapter
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Type,
			&i.Title,
			&i.Content,
			&i.WordCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGeneratedDocumentByID = `-- name: GetGeneratedDocumentByID :one
SELECT id, project_id, file_name, file_path, file_size, mime_type, status, created_at FROM generated_documents
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetGeneratedDocumentByID(ctx context.Context, id pgtype.UUID) (GeneratedDocument, error) {
	row := q.db.QueryRow(ctx, getGeneratedDocumentByID, id)
	var i GeneratedDocument
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getGeneratedDocumentsByProjectID = `-- name: GetGeneratedDocumentsByProjectID :many
SELECT id, project_id, file_name, file_path, file_size, mime_type, status, created_at FROM generated_documents
WHERE project_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetGeneratedDocumentsByProjectID(ctx context.Context, projectID pgtype.UUID) ([]GeneratedDocument, error) {
	rows, err := q.db.Query(ctx, getGeneratedDocumentsByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GeneratedDocument{}
	for rows.Next() {
		var i GeneratedDocument
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileName,
			&i.FilePath,
			&i.FileSize,
			&i.MimeType,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReferencesByProjectID = `-- name: GetReferencesByProjectID :many
SELECT id, project_id, title, authors, journal, publication_year, doi, url, citation_apa, citation_mla, created_at FROM "references" -- Quoted
WHERE project_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetReferencesByProjectID(ctx context.Context, projectID pgtype.UUID) ([]Reference, error) {
	rows, err := q.db.Query(ctx, getReferencesByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reference{}
	for rows.Next() {
		var i Reference
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Title,
			&i.Authors,
			&i.Journal,
			&i.PublicationYear,
			&i.Doi,
			&i.Url,
			&i.CitationApa,
			&i.CitationMla,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResearchProjectByID = `-- name: GetResearchProjectByID :one
SELECT id, user_id, title, specialization, university, description, status, created_at, updated_at FROM research_projects
WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetResearchProjectByIDParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) GetResearchProjectByID(ctx context.Context, arg GetResearchProjectByIDParams) (ResearchProject, error) {
	row := q.db.QueryRow(ctx, getResearchProjectByID, arg.ID, arg.UserID)
	var i ResearchProject
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Specialization,
		&i.University,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionByRefreshToken = `-- name: GetSessionByRefreshToken :one
SELECT id, user_id, refresh_token, user_agent, client_ip, is_blocked, expires_at, created_at FROM sessions
WHERE refresh_token = $1 LIMIT 1
`

func (q *Queries) GetSessionByRefreshToken(ctx context.Context, refreshToken string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByRefreshToken, refreshToken)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, first_name, last_name, is_verified, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, first_name, last_name, is_verified, created_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserResearchProjects = `-- name: GetUserResearchProjects :many
SELECT id, user_id, title, specialization, university, description, status, created_at, updated_at FROM research_projects
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetUserResearchProjects(ctx context.Context, userID pgtype.UUID) ([]ResearchProject, error) {
	rows, err := q.db.Query(ctx, getUserResearchProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ResearchProject{}
	for rows.Next() {
		var i ResearchProject
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Specialization,
			&i.University,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChapter = `-- name: UpdateChapter :one
UPDATE chapters
SET title = $2, content = $3, word_count = $4, status = $5, updated_at = NOW()
WHERE chapters.id = $1 AND project_id = (SELECT project_id FROM research_projects WHERE research_projects.id = $6 AND user_id = $7) -- ensure user owns project
RETURNING id, project_id, type, title, content, word_count, status, created_at, updated_at
`

type UpdateChapterParams struct {
	ID        pgtype.UUID `db:"id" json:"id"`
	Title     string      `db:"title" json:"title"`
	Content   pgtype.Text `db:"content" json:"content"`
	WordCount pgtype.Int4 `db:"word_count" json:"word_count"`
	Status    pgtype.Text `db:"status" json:"status"`
	ID_2      pgtype.UUID `db:"id_2" json:"id_2"`
	UserID    pgtype.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateChapter(ctx context.Context, arg UpdateChapterParams) (Chapter, error) {
	row := q.db.QueryRow(ctx, updateChapter,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.WordCount,
		arg.Status,
		arg.ID_2,
		arg.UserID,
	)
	var i Chapter
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Type,
		&i.Title,
		&i.Content,
		&i.WordCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGeneratedDocumentStatus = `-- name: UpdateGeneratedDocumentStatus :one
UPDATE generated_documents
SET status = $2
WHERE id = $1
RETURNING id, project_id, file_name, file_path, file_size, mime_type, status, created_at
`

type UpdateGeneratedDocumentStatusParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	Status pgtype.Text `db:"status" json:"status"`
}

func (q *Queries) UpdateGeneratedDocumentStatus(ctx context.Context, arg UpdateGeneratedDocumentStatusParams) (GeneratedDocument, error) {
	row := q.db.QueryRow(ctx, updateGeneratedDocumentStatus, arg.ID, arg.Status)
	var i GeneratedDocument
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateResearchProject = `-- name: UpdateResearchProject :one
UPDATE research_projects
SET title = $2, specialization = $3, university = $4, description = $5, status = $6, updated_at = NOW()
WHERE id = $1 AND user_id = $7
RETURNING id, user_id, title, specialization, university, description, status, created_at, updated_at
`

type UpdateResearchProjectParams struct {
	ID             pgtype.UUID `db:"id" json:"id"`
	Title          string      `db:"title" json:"title"`
	Specialization string      `db:"specialization" json:"specialization"`
	University     pgtype.Text `db:"university" json:"university"`
	Description    pgtype.Text `db:"description" json:"description"`
	Status         pgtype.Text `db:"status" json:"status"`
	UserID         pgtype.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateResearchProject(ctx context.Context, arg UpdateResearchProjectParams) (ResearchProject, error) {
	row := q.db.QueryRow(ctx, updateResearchProject,
		arg.ID,
		arg.Title,
		arg.Specialization,
		arg.University,
		arg.Description,
		arg.Status,
		arg.UserID,
	)
	var i ResearchProject
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Specialization,
		&i.University,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateResearchProjectStatus = `-- name: UpdateResearchProjectStatus :one
UPDATE research_projects
SET status = $2, updated_at = NOW()
WHERE id = $1 AND user_id = $3
RETURNING id, user_id, title, specialization, university, description, status, created_at, updated_at
`

type UpdateResearchProjectStatusParams struct {
	ID     pgtype.UUID `db:"id" json:"id"`
	Status pgtype.Text `db:"status" json:"status"`
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateResearchProjectStatus(ctx context.Context, arg UpdateResearchProjectStatusParams) (ResearchProject, error) {
	row := q.db.QueryRow(ctx, updateResearchProjectStatus, arg.ID, arg.Status, arg.UserID)
	var i ResearchProject
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Specialization,
		&i.University,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserVerificationStatus = `-- name: UpdateUserVerificationStatus :one
UPDATE users
SET is_verified = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, email, password_hash, first_name, last_name, is_verified, created_at, updated_at
`

type UpdateUserVerificationStatusParams struct {
	ID         pgtype.UUID `db:"id" json:"id"`
	IsVerified pgtype.Bool `db:"is_verified" json:"is_verified"`
}

func (q *Queries) UpdateUserVerificationStatus(ctx context.Context, arg UpdateUserVerificationStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationStatus, arg.ID, arg.IsVerified)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
